'''
<오목>

- 문제 -
오목은 바둑판에 검은 바둑알과 흰 바둑알을 교대로 놓아서 겨루는 게임이다. 
바둑판에는 19개의 가로줄과 19개의 세로줄이 그려져 있는데 
가로줄은 위에서부터 아래로 1번, 2번, ... ,19번의 번호가 붙고 
세로줄은 왼쪽에서부터 오른쪽으로 1번, 2번, ... 19번의 번호가 붙는다.

위의 그림에서와 같이 같은 색의 바둑알이 연속적으로 다섯 알을 놓이면 그 색이 이기게 된다. 
여기서 연속적이란 가로, 세로 또는 대각선 방향 모두를 뜻한다. 
즉, 위의 그림은 검은색이 이긴 경우이다. 
하지만 여섯 알 이상이 연속적으로 놓인 경우에는 이긴 것이 아니다.

입력으로 바둑판의 어떤 상태가 주어졌을 때,
검은색이 이겼는지, 
흰색이 이겼는지 또는 
아직 승부가 결정되지 않았는지를 판단하는 프로그램을 작성하시오. 

단, 검은색과 흰색이 동시에 이기거나 
검은색 또는 흰색이 두 군데 이상에서 동시에 이기는 경우는 입력으로 들어오지 않는다.

- 입력 -
19줄에 각 줄마다 19개의 숫자로 표현되는데, 
검은 바둑알은 1, 
흰 바둑알은 2, 
알이 놓이지 않는 자리는 0으로 표시되며, 
숫자는 한 칸씩 띄어서 표시된다.

- 출력 -
첫줄에 검은색이 이겼을 경우에는 1을, 
흰색이 이겼을 경우에는 2를, 
아직 승부가 결정되지 않았을 경우에는 0을 출력한다. 
검은색 또는 흰색이 이겼을 경우에는 
둘째 줄에 연속된 다섯 개의 바둑알 중에서 가장 왼쪽에 있는 바둑알
(연속된 다섯 개의 바둑알이 세로로 놓인 경우, 그 중 가장 위에 있는 것)의 가로줄 번호와, 세로줄 번호를 순서대로 출력한다.

- 예제 입력 1 -
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 0 0 2 2 2 1 0 0 0 0 0 0 0 0 0 0
0 0 1 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

- 예제 출력 1 -
1
3 2
'''

'''
1️⃣ IndexError
19번 코드를 while 0 <= nx + dx[i] < n and 0 <= ny + dy[i] < n and arr[x][y] == arr[nx][ny]:처럼 작성했다. 
물론 IndexError가 발생했는데, 
만약 현재 cnt = 4이고 다음 cnt를 셀 차례인데,
여기서 + dx[i], + dy[i] 칸만큼 더 가면 n의 범위를 벗어나기 때문에 오류가 발생한다.


2️⃣ 단락연산자
처음에 23번과 25번 각각 코드 순서를 앞뒤로 바꾸어서 작성했었다.
23번: if arr[nx][ny] == arr[nx + dx[i]][ny + dy[i]] and 0 <= nx + dx[i] < n and 0 <= ny + dy[i] < n:, 
25번: if arr[x][y] == arr[x - dx[i]][y - dy[i]] and 0 <= x - dx[i] < n and 0 <= y - dy[i] < n: 
이렇게 작성하니까 역시 IndexError가 발생했는데 

만약, 현재 좌표 arr[x][y]가 index 마지막 위치(arr[n][n])에 있다고 가정하면, 
다음 비교할 좌표인 arr[nx + dx[i]][ny + dy[i]]는 n의 범위를 벗어났기 때문에 비교할 수 없다. 따라서 오류가 발생한다. 

이때, 앞 뒤 순서를 바꾸면 앞 조건인 0 <= nx + dx[i] < n and 0 <= ny + dy[i] < n:에 먼저 걸리게 되고 
이후 단락 평가에 의해 뒤 조건은 비교하지 않고 곧바로 False 처리한다. 25번 코드도 마찬가지이다. 
단락 평가를 잘 모르겠다면 이전 글을 보자!


3️⃣ 육목 판단
연속된 바둑알이 육목인지 판별하는 방법은 2가지가 있다. 
첫 번째는 연속된 바둑알의 제일 마지막 좌표와 해당 좌표에서 한 칸(+ dx[i], + dy[i]) 더 이동한 좌표가 같은지 살펴보고, 
두 번째는 제일 처음 좌표와 해당 좌표에서 한 칸(- dx[i], - dy[i]) 덜 이동한 좌표가 같은지 살펴보는 것이다. 
말이 복잡한 것 같아보여 하단에 표를 직접 그려봤다.

4️⃣ return 인자 개수
승부가 났을 때 return하는 인자의 개수와 
승부가 나지 않았을 때 return하는 인자의 개수가 달랐다. 

그래서 return과 print()를 각각 사용하려다가 코드가 깔끔하지 않은 것 같아 
하나만 return하는 인자에 임의로 -1, -1을 붙여 3개로 맞췄고, 0을 return한 값에는 0만 출력하게 작성했다.

 
마지막으로 문제를 풀며 작성한 T.C를 하나 가져왔는데 문제가 안 풀린다면 테스트해보자. (19 * 19로 만들기 귀찮아서 6 * 6로 만들었다.)
'''